(in-package #:mykorz)

(defun init-env ()
  (set-primitive-slot))

(defun korz-test (src)
  (init-env)
  (eval-exp src (empty-env) (make-contexts nil)))

(defun main (file)
  (with-open-file (s file)
    (init-env)
    (do ((src (read s nil nil) (read s nil nil))
	 (env (empty-env))
	 (ctxt (make-contexts nil)))
	((not src) nil)
      (eval-exp src env ctxt))))

;;eval-exp
;;exp = S expression
;;(exp env ctxt) -> coordinate
;; *-exp-p : exp -> bool
;; *-exp : ([exp] env ctxt) -> coordinate
(defun eval-exp (exp env ctxt)
  @trace-cond
  (cond ((progn-exp-p exp) (eval-exps (progn-exp exp)
				      env ctxt))
	((method-exp-p exp)
	 (method-exp (method-context exp)
		     (method-id exp)
		     (method-params exp)
		     (method-body exp)
		     env ctxt))
	((var-exp-p exp)
	 (var-exp (var-context exp)
		  (var-id exp)
		  (var-value exp)
		  env ctxt))
	((def-exp-p exp)
	 (def-exp (def-context exp)
	          (def-id exp)
	          (def-value exp)
		  env ctxt))
	((if-exp-p exp)
	 (if-exp (if-test exp)
		 (if-then exp)
		 (if-else exp)
		 env ctxt))
	((let-exp-p exp)
	 (let-exp (let-var exp)
		  (let-body exp)
		  env ctxt))
	((set-exp-p exp)
	 (set-exp (set-id exp)
		  (set-value exp)
		  env ctxt))
	((quote-exp-p exp)
	 (quote-exp exp env ctxt))
	((call-exp-p exp)
	 (call-exp (call-exp-function exp)
		   (call-exp-args exp)
		   (call-exp-context exp)
		   env ctxt))
	((id-exp-p exp) (id-exp exp env ctxt))
	(t (immediate-exp exp))))

;;eval-exps : ([exp] env ctxt) -> coordinate

(defun eval-exps (exp env ctxt)
  (if (rest-exp-p exp)
      (progn (eval-exp (first-exp exp) env ctxt)
	     (eval-exps (rest-exp exp) env ctxt))
      (eval-exp (first-exp exp) env ctxt)))
